You are a software engineer helping me develop an app as described below. I want you to read all the contents I'm going to provide you to gain context and understanding of what we are going to develop. Wait for my instructions before you start writing any code. Please read the following contents and class codes to gain context and say DONE when you are done reading.


AutoLoc App Development Requirement Specifications

Requirement Specification for the AutoLoc App:

Overview:

AutoLoc is a sophisticated app designed for automating the localization process of any software source code such as websites and mobile apps. It extracts all translatable texts from the source code across various file types and converts them into locale resource files, facilitating easy translation. The application is developed using PySide6 Python framework and other relevant Python libraries.

Key Features:

Automatic Text Extraction:

Supports multiple file types.
Extracts translatable texts into resource files for each specified file type.
Users can define which file types to localize.

Localized Text Rendering:

The extracted texts in the appropriate format can be rendered back into the sourc code, maintaining the correct localization.

Class-based File Handling:

Each file type has a specific class that manages its localization process, ensuring appropriate handling according to file type characteristics.

Installation and Compatibility:

Compatible with all major operating systems.
Includes an installer that handles the installation of all dependencies.
The app is accessible via a UI icon, making it user-friendly and easy to execute.

App Code File Structure:

The following definitions describe the file and class structure of the AutoLoc app:

- AutoLoc

    - app_ui
        - main_app_window.py
            - MainAppWindow: class
        - header.py 
            - HeaderWidget: class 
        - side_bar.py 
            - SideBarWidget: class
        - footer.py 
            - FooterWidget: class
        - home.py 
            - HomeWidget: class  
        - settings.py
            - SettingsStackedWidget: class 
            - SettingsWidget: class 
            - LocalesWidget: class
            - LocaleWidget: class
            - AddLocaleWidget: class
            - UpdateLocaleWidget: class       
        - projects.py
            - ProjectsStackedWidget: class 
            - ProjectsWidget: class
            - ProjectWidget: class
            - AddProjectWidget: class
            - UpdateProjectWidget: class
        - source_codes.py
            - SourceCodesStackedWidget: class 
            - SourceCodesWidget: class
            - SourceCodeWidget: class
            - AddSourceCodeWidget: class
            - UpdateSourceCodeWidget: class
            - MergeSourceCodeLocalesCommonsWidget: class 
        - target_locales.py 
            - TargetLocalesWidget: class 
            - TargetLocaleWidget: class 
            - AddTargetLocaleWidget: class 
            - UpdateTargetLocaleWidget: class 
        - l10n.py 
            - L10nWidget: class 
        - slyles.py 
            - Styles: class 

    - managers
        - app_manager.py
            - AppManager: class
        - db_manager.py
            - DBManager: class
        - setting_manager.py
            - SettingManager: class
        - project_manager.py 
            - ProjectManager: class
        - source_code_manager.py 
            - SourceCodeManager: class
        - target_locale_manager.py
            - TargetLocaleManager: class  
        - l10n_manager.py 
            - L10nManager: class 

    - localizers
        - web_localizers
            - web_app_file_localizer.py 
                - WebAppFileLocalizer: class
            - web_app_html_file_localizer.py 
                - WebAppHTMLFileLocalizer: class
            - web_app_js_file_localizer.py 
                - WebAppJSFileLocalizer: class 
            - web_app_ejs_file_localizer.py
                - WebAppEJSFileLocalizer: class 
            - web_app_jsx_file_localizer.py
                - WebAppJSXFileLocalizer: class 
            - web_app_ts_file_localizer.py 
                - WebAppTSFileLocalizer: class 
            - web_app_tsx_file_localizer.py 
                - WebAppTSXFileLocalizer: class
            - web_app_vue_file_localizer.py 
                - WebAppVueFileLocalizer: class 
            - web_app_json_file_localizer.py 
                - WebAppJSONFileLocalizer: class 
            - web_app_csv_file_localizer.py 
                - WebAppCSVFileLocalizer: class

        - android_localizers
            - android_app_file_localizer.py 
                - AndroidAppFileLocalizer: class 
            - android_app_xml_file_localizer.py 
                - AndroidAppXMLFileLocalizer: class
            - android_app_java_file_localizer.py 
                - AndroidAppJavaFileLocalizer: class 
            - android_app_kotlin_file_localizer.py 
                - AndroidAppKotlinFileLocalizer: class 

        - ios_localizers
            - ios_app_file_localizer.py 
                - IOSAppFileLocalizer: class 
            - ios_app_swift_file_localizer.py 
                - IOSAppSwiftFileLocalizer: class 
            - ios_app_objc_m_file_localizer.py 
                - IOSAppObjcMFileLocalizer: class 
            - ios_app_objc_h_file_localizer.py 
                - IOSAppObjcHFileLocalizer: class 
            - ios_app_strings_file_localizer.py 
                - IOSAppStringsFileLocalizer: class
            - ios_app_storyboard_file_localizer.py 
                - IOSAppStoryboardFileLocalizer: class
            - ios_app_xib_file_localizer.py 
                - IOSAppXIBFileLocalizer: class
            - ios_app_plist_file_localizer.py 
                - IOSAppPListFileLocalizer: class
            
        - java_localizers
            - java_app_file_localizer.py 
                - JavaAppFileLocalizer: class 
            - java_app_xhtml_file_localizer.py
                - JavaAppXHTMLFileLocalizer: class 
            - java_app_xml_file_localizer.py
                - JavaAppXMLFileLocalizer: class 
            - java_app_java_file_localizer.py
                - JavaAppJavaFileLocalizer: class 
            - java_app_properties_file_localizer.py
                - JavaAppPropertiesFileLocalizer: class 
            
    - autoloc.py (app's starter)


Code and Functionality Definitions:

Class Definitions:

The following is the definition of each class's functionality and implementation logic. The classes are developed in the following logical order to faciliate a smooth definition of the interrelationship among them. Inheritances will be explicitly defined by indicating which class inherits which class in the following definiton. Each class's functionality will also be described and finetuned as appropriate during the course of development. The logical order in which classes are defined is as follows:
- managers module classes
- localizers module classes
- app_ui module classes 


These are the codes so far developed in the AutoLoc App. I want you to read them to gain context and understanding of their functionalities. I will prompt you later to modify or enhance them as we go on the development journey. 

Please say DONE When you are done reading and understanding the following codes:


1. error_manager.py:

class AppError(Exception):
    """Base class for all application errors."""
    pass


class InitializationError(AppError):
    """Raised when there is an initialization error."""
    pass


class PermissionError(AppError):
    """Raised when there is a permission error."""
    pass


class DatabaseError(AppError):
    """Raised when there is a database creation or access error."""
    pass


class DatabaseConnectionError(DatabaseError):
    """Raised when there is a problem connecting to or interacting with the database."""
    pass


class FileTypeError(AppError):
    """Raised when an unsupported or invalid file type is encountered."""
    pass


class TextExtractionError(AppError):
    """Raised when there is an issue extracting translatable text from a file."""
    pass


class LocalizationRenderError(AppError):
    """Raised when rendering localized text back into the source code fails."""
    pass


class ConfigurationError(AppError):
    """Raised when there is an error in the app's configuration settings."""
    pass


class DependencyError(AppError):
    """Raised when a required dependency is missing or cannot be loaded."""
    pass


class ResourceFileError(AppError):
    """Raised when there is an error with locale resource files (creating, reading, or writing)."""
    pass


class UIError(AppError):
    """Raised when there is an issue with the user interface."""
    pass


class InvalidUserInputError(AppError):
    """Raised when the user provides invalid input through the UI."""
    pass


class FilePermissionError(AppError):
    """Raised when there is an issue with file or directory permissions."""
    pass


class LocaleManagementError(AppError):
    """Raised when there is an issue managing locale settings."""
    pass


2. app_manager.py:

import os
import sys
import sqlite3
from error_manager import (
    AppError,
    InitializationError,
    PermissionError,
    DatabaseError,
    DatabaseConnectionError,
    FilePermissionError,
    ConfigurationError,
    DependencyError,
)

class AppManager:
    """
    The AppManager manages the app's startup functionalities, initializes the app's data and database paths, 
    and handles errors and exceptions related to these tasks.
    """

    def __init__(self):
        # Define the application's data paths
        self.app_data_path = os.path.join(self.get_user_data_directory(), "AutoLoc", "Data")
        self.app_db_file_path = os.path.join(self.app_data_path, "DB", "autoloc.db")

        # Run the app initialization
        try:
            self.initialize_app()
        except AppError as e:
            print(f"Error in AppManager {e}")

    def get_user_data_directory(self):
        """
        Returns the user data directory path based on the host OS.
        :return: The path to the user's data directory
        """
        try:
            if sys.platform == 'win32':
                return os.getenv('APPDATA')
            elif sys.platform == 'darwin':
                return os.path.expanduser('~/Library/Application Support')
            else:  # Linux and other Unix-like systems
                return os.path.expanduser('~/.local/share')
        except Exception as e:
            raise InitializationError(f"AppManager Error fetching user data directory: {str(e)}")

    def initialize_app(self):
        """
        Checks and ensures that the app's data and database paths are properly set up.
        Creates the necessary directories and files if they do not exist.
        """
        try:
            # Check and create the data directory if it doesn't exist
            if not os.path.exists(self.app_data_path):
                os.makedirs(self.app_data_path)

            # Check and create the DB directory if it doesn't exist
            db_directory = os.path.dirname(self.app_db_file_path)
            if not os.path.exists(db_directory):
                os.makedirs(db_directory)

            # Check and set the necessary permissions for the data directory
            self.ensure_write_permissions(self.app_data_path)
            self.ensure_write_permissions(db_directory)

            # Check and create the SQLite DB file if it doesn't exist
            if not os.path.exists(self.app_db_file_path):
                self.create_db_file()
            else:
                # Ensure the database file is writable
                self.ensure_write_permissions(self.app_db_file_path)

        except (FilePermissionError, DatabaseError, PermissionError) as e:
            raise InitializationError(f"AppManager Initialization Error: {str(e)}")

    def ensure_write_permissions(self, path):
        """
        Ensures that the given path has the necessary write permissions.
        :param path: The file or directory path to check
        """
        try:
            if not os.access(path, os.W_OK):
                # Attempt to add write permission
                os.chmod(path, 0o700)  # Grant read, write, and execute permissions to the owner
        except Exception as e:
            raise FilePermissionError(f"AppManager Permission Error: Unable to set write permissions for {path}: {str(e)}")

    def create_db_file(self):
        """
        Creates the SQLite database file at the specified path.
        """
        try:
            conn = sqlite3.connect(self.app_db_file_path)
            conn.close()
        except sqlite3.DatabaseError as e:
            raise DatabaseConnectionError(f"AppManager Database Creation Error: {str(e)}")

    def get_app_data_path(self):
        """
        Returns the application's data directory path.
        :return: The app data path
        """
        return self.app_data_path

    def get_app_db_file_path(self):
        """
        Returns the application's database file path.
        :return: The app database file path
        """
        return self.app_db_file_path


3. test_app_manager.py:

import os
from app_manager import AppManager
from error_manager import (  # Import specific exceptions
    InitializationError,
    PermissionError,
    DatabaseError,
    FilePermissionError,
    DatabaseConnectionError,
)

def test_app_manager():
    print("Testing AppManager...")

    # Create an instance of AppManager
    try:
        app_manager = AppManager()
        print("AppManager initialized successfully.")
    except (InitializationError, PermissionError, DatabaseError, FilePermissionError, DatabaseConnectionError) as e:
        print(f"AppManager Initialization Error: {e}")
        return

    # Test get_user_data_directory method
    try:
        user_data_dir = app_manager.get_user_data_directory()
        print(f"User Data Directory: {user_data_dir}")
        if not user_data_dir:
            print("Error: Failed to retrieve user data directory.")
    except InitializationError as e:
        print(f"Get User Data Directory Error: {e}")

    # Test get_app_data_path method
    try:
        app_data_path = app_manager.get_app_data_path()
        print(f"App Data Path: {app_data_path}")
        if not os.path.exists(app_data_path):
            print("Error: App data path does not exist.")
    except Exception as e:
        print(f"Get App Data Path Error: {e}")

    # Test get_app_db_file_path method
    try:
        app_db_file_path = app_manager.get_app_db_file_path()
        print(f"App DB File Path: {app_db_file_path}")
        if not os.path.exists(app_db_file_path):
            print("Error: App DB file does not exist.")
    except Exception as e:
        print(f"Get App DB File Path Error: {e}")

    # Test permissions for app data directory
    try:
        if os.access(app_data_path, os.W_OK):
            print("App data path is writable.")
        else:
            print("Error: App data path is not writable.")
            app_manager.ensure_write_permissions(app_data_path)
            if os.access(app_data_path, os.W_OK):
                print("Permissions corrected: App data path is now writable.")
            else:
                print("Failed to set write permissions for app data path.")
    except FilePermissionError as e:
        print(f"Permission Test Error for App Data Path: {e}")

    # Test permissions for DB file
    try:
        if os.access(app_db_file_path, os.W_OK):
            print("Database file is writable.")
        else:
            print("Error: Database file is not writable.")
            app_manager.ensure_write_permissions(app_db_file_path)
            if os.access(app_db_file_path, os.W_OK):
                print("Permissions corrected: Database file is now writable.")
            else:
                print("Failed to set write permissions for database file.")
    except FilePermissionError as e:
        print(f"Permission Test Error for Database File: {e}")

    # Test initialize_app method
    try:
        app_manager.initialize_app()
        print("App initialized successfully.")
    except InitializationError as e:
        print(f"Initialization Error: {e}")

    # Test create_db_file method
    try:
        app_manager.create_db_file()
        if not os.path.exists(app_manager.get_app_db_file_path()):
            print("Error: Database file was not created successfully.")
        else:
            print("Database file created successfully.")
    except DatabaseConnectionError as e:
        print(f"Create DB File Error: {e}")

    print("AppManager tests completed.")

if __name__ == "__main__":
    test_app_manager()


4. default_data.py:

# Dictionary for create table statements
CREATE_TABLE_STATEMENTS = {
    'app_settings': """
        CREATE TABLE IF NOT EXISTS app_settings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            dark_mode BOOLEAN DEFAULT FALSE,
            duplicate_html BOOLEAN DEFAULT FALSE,
            use_key_namespace BOOLEAN DEFAULT FALSE,
            UNIQUE(id)
        )
    """,
    'file_types': """
        CREATE TABLE IF NOT EXISTS file_types (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            code_type TEXT,
            name TEXT,
            extension TEXT,
            is_active BOOLEAN DEFAULT TRUE,
            UNIQUE(code_type, name, extension)
        )
    """,
    'locales': """
        CREATE TABLE IF NOT EXISTS locales (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            code TEXT,
            UNIQUE(name, code)
        )
    """,
    'projects': """
        CREATE TABLE IF NOT EXISTS projects (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            unique_id TEXT,
            client TEXT,
            description TEXT,
            status TEXT DEFAULT 'In Progress',
            start_date TEXT NULL,
            end_date TEXT NULL,
            last_updated_date TEXT NULL,
            lead_engineer TEXT NULL,
            UNIQUE(name, client, unique_id)
        )
    """,
    'source_codes': """
        CREATE TABLE IF NOT EXISTS source_codes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            project_id INTEGER,
            name TEXT,
            unique_id TEXT,
            code_type TEXT,
            source_locale TEXT,
            original_source_code_path TEXT NULL,
            commons_paths TEXT NULL,
            localized_source_code_path TEXT NULL,
            status TEXT DEFAULT 'In Progress',
            notes TEXT NULL,
            UNIQUE(project_id, name, unique_id, source_locale),
            FOREIGN KEY(project_id) REFERENCES projects(id)
        )
    """,
    'target_locales': """
        CREATE TABLE IF NOT EXISTS target_locales (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            code TEXT,
            source_code_id INTEGER,
            UNIQUE(name, code, source_code_id),
            FOREIGN KEY(source_code_id) REFERENCES source_codes(id)
        )
    """
}

# Dictionary for default records
DEFAULT_RECORDS = {
    'app_settings': [
        (1, False, False, False)
    ],
    'locales': [
        ('Japanese', 'ja-JP'),
        ('English (US)', 'en-US'),
        ('Simplified Chinese (CN)', 'zh-CN'),
        ('Traditional Chinese (TW)', 'zh-TW'),
        ('Korean (South Korea)', 'ko-KR')
    ],
    'file_types': [
        ('Web App', 'HTML', '.html'),
        ('Web App', 'JavaScript', '.js'),
        ('Web App', 'Embedded JavaScript (EJS)', '.ejs'),
        ('Web App', 'TypeScript', '.ts'),
        ('Web App', 'TypeScript XML (TSX)', '.tsx'),
        ('Web App', 'React JSX', '.jsx'),
        ('Web App', 'Vue Single-File Component', '.vue'),
        ('Web App', 'JSON', '.json'),
        ('Android App', 'Android Layout XML Files', '.xml'),
        ('Android App', 'Java Source File', '.java'),
        ('Android App', 'Kotlin Source File', '.kt'),
        ('Android App', 'Android Resource Files', '.xml'),
        ('Android App', 'Android Manifest File', '.xml'),
        ('iOS App', 'Swift Source File', '.swift'),
        ('iOS App', 'Objective-C Implementation File', '.m'),
        ('iOS App', 'Objective-C Header File', '.h'),
        ('iOS App', 'iOS Localizable Strings File', '.strings'),
        ('iOS App', 'Storyboard Interface File', '.storyboard'),
        ('iOS App', 'XIB Interface Builder File', '.xib'),
        ('iOS App', 'Property List Files', '.plist'),
        ('Java App', 'JSF View Files', '.xhtml'),
        ('Java App', 'Java XML File', '.xml'),
        ('Java App', 'Java Source File', '.java'),
        ('Java App', 'Java Properties File', '.properties')
    ]
}


5. db_manager.py:

from app_manager import AppManager
import sqlite3
import os
from error_manager import (
    DatabaseError,
    DatabaseConnectionError,
    FilePermissionError,
    InitializationError,
)
from default_data import CREATE_TABLE_STATEMENTS, DEFAULT_RECORDS

class DBManager:
    """
    The DBManager handles all database-related functionalities of the AutoLoc app.
    It manages the creation and management of the SQLite database, tables, and records.
    """

    def __init__(self):
        # Initialize AppManager and retrieve the database file path
        try:
            app_manager = AppManager()  # Initialize the AppManager class
            self.app_db_file_path = app_manager.get_app_db_file_path()
            self.connection = None
            self.connect_db()
            self.create_db()
            self.create_tables()
            self.insert_records()
        except (InitializationError, DatabaseError) as e:
            raise InitializationError(f"DBManager Initialization Error: {str(e)}")

    def connect_db(self):
        """
        Establishes a connection to the SQLite database file.
        """
        try:
            self.connection = sqlite3.connect(self.app_db_file_path)
            self.connection.row_factory = sqlite3.Row  # Set row factory to return rows as sqlite3.Row objects
        except sqlite3.DatabaseError as e:
            raise DatabaseConnectionError(f"DBManager Connection Error: {str(e)}")

    def create_db(self):
        """
        Creates the SQLite database file if it does not exist.
        """
        try:
            if not os.path.exists(self.app_db_file_path):
                open(self.app_db_file_path, 'w').close()
        except Exception as e:
            raise DatabaseError(f"DBManager Database Creation Error: {str(e)}")

    def create_tables(self):
        """
        Creates the necessary tables in the SQLite database if they do not exist.
        """
        try:
            cursor = self.connection.cursor()
            # Execute each create table statement from the imported dictionary
            for table_name, create_statement in CREATE_TABLE_STATEMENTS.items():
                cursor.execute(create_statement)
            self.connection.commit()
        except sqlite3.DatabaseError as e:
            raise DatabaseError(f"DBManager Table Creation Error: {str(e)}")

    def insert_records(self):
        """
        Inserts default records into the tables.
        """
        try:
            cursor = self.connection.cursor()

            # Insert default records from the imported dictionary
            for table_name, records in DEFAULT_RECORDS.items():
                if table_name == 'app_settings':
                    cursor.executemany(f"""
                        INSERT OR IGNORE INTO {table_name} (id, dark_mode, duplicate_html, use_key_namespace) 
                        VALUES (?, ?, ?, ?)
                    """, records)
                elif table_name == 'locales':
                    cursor.executemany(f"INSERT OR IGNORE INTO {table_name} (name, code) VALUES (?, ?)", records)
                elif table_name == 'file_types':
                    cursor.executemany(f"""
                        INSERT OR IGNORE INTO {table_name} (code_type, name, extension, is_active) 
                        VALUES (?, ?, ?, TRUE)
                    """, records)

            self.connection.commit()
            print("Default records inserted into the tables successfully.")
        except sqlite3.DatabaseError as e:
            raise DatabaseError(f"DBManager Record Insertion Error: {str(e)}")

    def reset_db(self):
        """
        Resets the database by deleting all records from each table
        and recreating default records as needed.
        """
        try:
            # Connect to the database
            self.connect_db()

            # Clear all records from each table using delete_records method
            self.delete_records('app_settings')
            self.delete_records('locales')
            self.delete_records('projects')
            self.delete_records('source_codes')
            self.delete_records('target_locales')
            self.delete_records('file_types')

            # Insert default records into DB
            self.insert_records()
            
            print("Database reset successfully by clearing all tables.")
        except (DatabaseError, DatabaseConnectionError) as e:
            raise DatabaseError(f"DBManager DB Reset Error: {str(e)}")
    
    def get_records(self, table_name):
        """
        Retrieves all records from a given table.
        :param table_name: The name of the table to query
        :return: A list of records or an error message
        """
        try:
            cursor = self.connection.cursor()
            cursor.execute(f"SELECT * FROM {table_name}")
            return cursor.fetchall()
        except sqlite3.DatabaseError as e:
            raise DatabaseError(f"DBManager Get Records Error from {table_name}: {str(e)}")

    def get_record(self, table_name, record_id):
        """
        Retrieves a specific record from a given table.
        :param table_name: The name of the table to query
        :param record_id: The ID of the record to retrieve
        :return: The record data or an error message
        """
        try:
            cursor = self.connection.cursor()
            cursor.execute(f"SELECT * FROM {table_name} WHERE id = ?", (record_id,))
            return cursor.fetchone()
        except sqlite3.DatabaseError as e:
            raise DatabaseError(f"DBManager Get Record Error from {table_name}: {str(e)}")
    
    def insert_record(self, table_name, data):
        """
        Inserts a record into a specified table.
        :param table_name: The name of the table to insert data into
        :param data: A dictionary containing column names as keys and data as values
        :return: The inserted record or an error message
        """
        try:
            cursor = self.connection.cursor()
            columns = ', '.join(data.keys())
            placeholders = ', '.join(['?'] * len(data))
            cursor.execute(f"INSERT INTO {table_name} ({columns}) VALUES ({placeholders})", tuple(data.values()))
            self.connection.commit()
            # Fetch and return the inserted record
            return self.get_record(table_name, cursor.lastrowid)
        except sqlite3.DatabaseError as e:
            raise DatabaseError(f"DBManager Insert Record Error in {table_name}: {str(e)}")

    def update_record(self, table_name, record_id, data):
        """
        Updates a specific record in a given table.
        :param table_name: The name of the table to update
        :param record_id: The ID of the record to update
        :param data: A dictionary containing column names as keys and updated data as values
        :return: The updated record or an error message
        """
        try:
            cursor = self.connection.cursor()
            updates = ', '.join([f"{k} = ?" for k in data.keys()])
            values = list(data.values()) + [record_id]
            cursor.execute(f"UPDATE {table_name} SET {updates} WHERE id = ?", values)
            self.connection.commit()
            # Fetch and return the updated record
            return self.get_record(table_name, record_id)
        except sqlite3.DatabaseError as e:
            raise DatabaseError(f"DBManager Update Record Error in {table_name}: {str(e)}")

    def delete_record(self, table_name, record_id):
        """
        Deletes a specific record from a given table.
        :param table_name: The name of the table to delete data from
        :param record_id: The ID of the record to delete
        :return: The deleted record or an error message
        """
        try:
            # Fetch the record before deletion
            record_to_delete = self.get_record(table_name, record_id)
            cursor = self.connection.cursor()
            cursor.execute(f"DELETE FROM {table_name} WHERE id = ?", (record_id,))
            self.connection.commit()
            return record_to_delete  # Return the deleted record
        except sqlite3.DatabaseError as e:
            raise DatabaseError(f"DBManager Delete Record Error from {table_name}: {str(e)}")
    
    def delete_records(self, table_name):
        """
        Deletes all records from a given table.
        :param table_name: The name of the table to clear
        :return: List of all deleted records or an error message
        """
        try:
            # Fetch all records before deletion
            records_to_delete = self.get_records(table_name)
            cursor = self.connection.cursor()
            cursor.execute(f"DELETE FROM {table_name}")
            self.connection.commit()
            return records_to_delete  # Return all deleted records
        except sqlite3.DatabaseError as e:
            raise DatabaseError(f"DBManager Delete Records Error from {table_name}: {str(e)}")

    def close_connection(self):
        """
        Closes the SQLite database connection.
        """
        if self.connection:
            self.connection.close()


6. test_db_manager.py:

    from db_manager import DBManager
    from error_manager import (
        DatabaseError,
        DatabaseConnectionError,
        FilePermissionError,
        InitializationError,
    )
    import os

    # Initialize DBManager
    db_manager = DBManager()

    # 1. Test `insert_record` function
    try:
        data = {'name': 'Test Project', 'client': 'Client A', 'description': 'A sample project'}
        inserted_record = db_manager.insert_record('projects', data)
        assert inserted_record['name'] == 'Test Project', f"Expected 'Test Project', got {inserted_record['name']}"
        assert inserted_record['client'] == 'Client A', f"Expected 'Client A', got {inserted_record['client']}"
        print("Test insert_record: Passed")
    except DatabaseError as e:
        print(f"Test insert_record: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test insert_record: Failed with Exception: {str(e)}")

    # 2. Test `update_record` function
    try:
        record_id = inserted_record['id']
        updated_data = {'name': 'Updated Project', 'client': 'Client B', 'description': 'Updated description'}
        updated_record = db_manager.update_record('projects', record_id, updated_data)
        assert updated_record['name'] == 'Updated Project', f"Expected 'Updated Project', got {updated_record['name']}"
        assert updated_record['client'] == 'Client B', f"Expected 'Client B', got {updated_record['client']}"
        print("Test update_record: Passed")
    except DatabaseError as e:
        print(f"Test update_record: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test update_record: Failed with Exception: {str(e)}")

    # 3. Test `delete_record` function
    try:
        deleted_record = db_manager.delete_record('projects', record_id)
        assert deleted_record['id'] == record_id, f"Expected ID {record_id}, got {deleted_record['id']}"
        assert deleted_record['name'] == 'Updated Project', f"Expected 'Updated Project', got {deleted_record['name']}"
        print("Test delete_record: Passed")
    except DatabaseError as e:
        print(f"Test delete_record: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test delete_record: Failed with Exception: {str(e)}")

    # 4. Test `get_records` function
    try:
        records = db_manager.get_records('projects')
        assert isinstance(records, list), f"Expected list, got {type(records)}"
        print("Test get_records: Passed")
    except DatabaseError as e:
        print(f"Test get_records: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test get_records: Failed with Exception: {str(e)}")

    # 5. Test `get_record` function
    try:
        if records:
            record_id = records[0]['id']
            record = db_manager.get_record('projects', record_id)
            assert isinstance(record, sqlite3.Row), f"Expected sqlite3.Row, got {type(record)}"
            assert record['id'] == record_id, f"Expected ID {record_id}, got {record['id']}"
            print("Test get_record: Passed")
        else:
            print("No records found to test get_record.")
    except DatabaseError as e:
        print(f"Test get_record: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test get_record: Failed with Exception: {str(e)}")

    # 6. Test `delete_records` function
    try:
        deleted_records = db_manager.delete_records('projects')
        assert isinstance(deleted_records, list), f"Expected list, got {type(deleted_records)}"
        print("Test delete_records: Passed")
    except DatabaseError as e:
        print(f"Test delete_records: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test delete_records: Failed with Exception: {str(e)}")

    # 7. Test `reset_db` function
    try:
        result = db_manager.reset_db()
        assert result is None, f"Unexpected result: {result}"
        print("Test reset_db: Passed")
    except DatabaseError as e:
        print(f"Test reset_db: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test reset_db: Failed with Exception: {str(e)}")

    # 8. Test `create_tables` function
    try:
        result = db_manager.create_tables()
        assert result is None, f"Unexpected result: {result}"
        print("Test create_tables: Passed")
    except DatabaseError as e:
        print(f"Test create_tables: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test create_tables: Failed with Exception: {str(e)}")

    # 9. Test `close_connection` function
    try:
        db_manager.close_connection()
        print("Test close_connection: Passed")
    except Exception as e:
        print(f"Test close_connection: Failed with Exception: {str(e)}")



7. setting_manager.py:

from db_manager import DBManager
from error_manager import (
    InitializationError,
    DatabaseError,
    InvalidUserInputError,
    LocaleManagementError,
    FileTypeError
)

class SettingManager:
    """
    The SettingManager class is responsible for managing application settings,
    locales, and file types using the DBManager's CRUD functionalities.
    """

    def __init__(self):
        """
        Initializes the SettingManager by creating an instance of DBManager.
        """
        try:
            self.db_manager = DBManager()  # Initialize DBManager
        except InitializationError as e:
            raise InitializationError(f"SettingManager Initialization Error: {str(e)}")

    def update_app_settings(self, settings):
        """
        Updates the application settings in the app_settings table.
        :param settings: A dictionary containing the settings to update.
        :return: The updated app settings record.
        :raises DatabaseError: If there is an error during the update.
        """
        try:
            return self.db_manager.update_record('app_settings', 1, settings)
        except DatabaseError as e:
            raise DatabaseError(f"SettingManager Update App Settings Error: {str(e)}")

    def reset_db(self):
        """
        Resets the database by calling the reset_db method from DBManager.
        :raises DatabaseError: If there is an error during the reset.
        """
        try:
            self.db_manager.reset_db()
        except DatabaseError as e:
            raise DatabaseError(f"SettingManager Reset DB Error: {str(e)}")

    def get_locales(self):
        """
        Retrieves all locales from the locales table.
        :return: A list of all locales.
        :raises LocaleManagementError: If there is an error during retrieval.
        """
        try:
            return self.db_manager.get_records('locales')
        except DatabaseError as e:
            raise LocaleManagementError(f"SettingManager Get Locales Error: {str(e)}")

    def get_locale(self, locale_id):
        """
        Retrieves a specific locale by ID from the locales table.
        :param locale_id: The ID of the locale to retrieve.
        :return: The locale record.
        :raises LocaleManagementError: If there is an error during retrieval.
        """
        try:
            return self.db_manager.get_record('locales', locale_id)
        except DatabaseError as e:
            raise LocaleManagementError(f"SettingManager Get Locale Error: {str(e)}")

    def add_locale(self, name, code):
        """
        Adds a new locale to the locales table.
        :param name: The name of the locale.
        :param code: The code of the locale.
        :return: The inserted locale record.
        :raises LocaleManagementError: If there is an error during insertion.
        """
        try:
            return self.db_manager.insert_record('locales', {'name': name, 'code': code})
        except DatabaseError as e:
            raise LocaleManagementError(f"SettingManager Add Locale Error: {str(e)}")

    def update_locale(self, locale_id, data):
        """
        Updates a specific locale in the locales table.
        :param locale_id: The ID of the locale to update.
        :param data: A dictionary with updated locale information.
        :return: The updated locale record.
        :raises LocaleManagementError: If there is an error during update.
        """
        try:
            return self.db_manager.update_record('locales', locale_id, data)
        except DatabaseError as e:
            raise LocaleManagementError(f"SettingManager Update Locale Error: {str(e)}")

    def delete_locale(self, locale_id):
        """
        Deletes a specific locale from the locales table.
        :param locale_id: The ID of the locale to delete.
        :return: The deleted locale record.
        :raises LocaleManagementError: If there is an error during deletion.
        """
        try:
            return self.db_manager.delete_record('locales', locale_id)
        except DatabaseError as e:
            raise LocaleManagementError(f"SettingManager Delete Locale Error: {str(e)}")

    def delete_locales(self):
        """
        Deletes all locales from the locales table.
        :return: List of all deleted locale records.
        :raises LocaleManagementError: If there is an error during deletion.
        """
        try:
            return self.db_manager.delete_records('locales')
        except DatabaseError as e:
            raise LocaleManagementError(f"SettingManager Delete Locales Error: {str(e)}")

    def get_file_types(self):
        """
        Retrieves all file types from the file_types table.
        :return: A list of all file types.
        :raises FileTypeError: If there is an error during retrieval.
        """
        try:
            return self.db_manager.get_records('file_types')
        except DatabaseError as e:
            raise FileTypeError(f"SettingManager Get File Types Error: {str(e)}")

    def get_file_type(self, file_type_id):
        """
        Retrieves a specific file type by ID from the file_types table.
        :param file_type_id: The ID of the file type to retrieve.
        :return: The file type record.
        :raises FileTypeError: If there is an error during retrieval.
        """
        try:
            return self.db_manager.get_record('file_types', file_type_id)
        except DatabaseError as e:
            raise FileTypeError(f"SettingManager Get File Type Error: {str(e)}")

    def add_file_type(self, code_type, name, extension):
        """
        Adds a new file type to the file_types table.
        :param code_type: The type of code (e.g., 'Web App').
        :param name: The name of the file type.
        :param extension: The file extension (e.g., '.html').
        :return: The inserted file type record.
        :raises FileTypeError: If there is an error during insertion.
        """
        try:
            return self.db_manager.insert_record('file_types', {
                'code_type': code_type,
                'name': name,
                'extension': extension,
                'is_active': True
            })
        except DatabaseError as e:
            raise FileTypeError(f"SettingManager Add File Type Error: {str(e)}")

    def update_file_type(self, file_type_id, data):
        """
        Updates a specific file type in the file_types table.
        :param file_type_id: The ID of the file type to update.
        :param data: A dictionary with updated file type information.
        :return: The updated file type record.
        :raises FileTypeError: If there is an error during update.
        """
        try:
            return self.db_manager.update_record('file_types', file_type_id, data)
        except DatabaseError as e:
            raise FileTypeError(f"SettingManager Update File Type Error: {str(e)}")

    def delete_file_type(self, file_type_id):
        """
        Deletes a specific file type from the file_types table.
        :param file_type_id: The ID of the file type to delete.
        :return: The deleted file type record.
        :raises FileTypeError: If there is an error during deletion.
        """
        try:
            return self.db_manager.delete_record('file_types', file_type_id)
        except DatabaseError as e:
            raise FileTypeError(f"SettingManager Delete File Type Error: {str(e)}")

    def delete_file_types(self):
        """
        Deletes all file types from the file_types table.
        :return: List of all deleted file type records.
        :raises FileTypeError: If there is an error during deletion.
        """
        try:
            return self.db_manager.delete_records('file_types')
        except DatabaseError as e:
            raise FileTypeError(f"SettingManager Delete File Types Error: {str(e)}")


8. test_setting_manager.py:

    from setting_manager import SettingManager
    from error_manager import (
        InitializationError,
        DatabaseError,
        LocaleManagementError,
        FileTypeError
    )

    # Create an instance of SettingManager
    setting_manager = SettingManager()

    # 1. Test `update_app_settings` function
    try:
        settings = {'dark_mode': True, 'duplicate_html': True, 'use_key_namespace': False}
        updated_settings = setting_manager.update_app_settings(settings)
        assert updated_settings['dark_mode'] is True, f"Expected True, got {updated_settings['dark_mode']}"
        assert updated_settings['duplicate_html'] is True, f"Expected True, got {updated_settings['duplicate_html']}"
        assert updated_settings['use_key_namespace'] is False, f"Expected False, got {updated_settings['use_key_namespace']}"
        print("Test update_app_settings: Passed")
    except DatabaseError as e:
        print(f"Test update_app_settings: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test update_app_settings: Failed with Exception: {str(e)}")

    # 2. Test `reset_db` function
    try:
        result = setting_manager.reset_db()
        assert result is None, f"Unexpected result: {result}"
        print("Test reset_db: Passed")
    except DatabaseError as e:
        print(f"Test reset_db: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test reset_db: Failed with Exception: {str(e)}")

    # 3. Test `get_locales` function
    try:
        locales = setting_manager.get_locales()
        assert isinstance(locales, list), f"Expected list, got {type(locales)}"
        print("Test get_locales: Passed")
    except LocaleManagementError as e:
        print(f"Test get_locales: Failed with LocaleManagementError: {str(e)}")
    except Exception as e:
        print(f"Test get_locales: Failed with Exception: {str(e)}")

    # # 4. Test `get_locale` function
    # try:
    #     locale_id = 1  # Assume 1 is a valid ID
    #     locale = setting_manager.get_locale(locale_id)
    #     assert isinstance(locale, sqlite3.Row), f"Expected sqlite3.Row, got {type(locale)}"
    #     assert locale['id'] == locale_id, f"Expected ID {locale_id}, got {locale['id']}"
    #     print("Test get_locale: Passed")
    # except LocaleManagementError as e:
    #     print(f"Test get_locale: Failed with LocaleManagementError: {str(e)}")
    # except Exception as e:
    #     print(f"Test get_locale: Failed with Exception: {str(e)}")

    # 5. Test `add_locale` function
    try:
        new_locale = setting_manager.add_locale('Spanish', 'es-ES')
        assert new_locale['name'] == 'Spanish', f"Expected 'Spanish', got {new_locale['name']}"
        assert new_locale['code'] == 'es-ES', f"Expected 'es-ES', got {new_locale['code']}"
        print("Test add_locale: Passed")
    except LocaleManagementError as e:
        print(f"Test add_locale: Failed with LocaleManagementError: {str(e)}")
    except Exception as e:
        print(f"Test add_locale: Failed with Exception: {str(e)}")

    # 6. Test `update_locale` function
    try:
        locale_id = new_locale['id']
        updated_locale = setting_manager.update_locale(locale_id, {'name': 'French', 'code': 'fr-FR'})
        assert updated_locale['name'] == 'French', f"Expected 'French', got {updated_locale['name']}"
        assert updated_locale['code'] == 'fr-FR', f"Expected 'fr-FR', got {updated_locale['code']}"
        print("Test update_locale: Passed")
    except LocaleManagementError as e:
        print(f"Test update_locale: Failed with LocaleManagementError: {str(e)}")
    except Exception as e:
        print(f"Test update_locale: Failed with Exception: {str(e)}")

    # 7. Test `delete_locale` function
    try:
        deleted_locale = setting_manager.delete_locale(locale_id)
        assert deleted_locale['id'] == locale_id, f"Expected ID {locale_id}, got {deleted_locale['id']}"
        assert deleted_locale['name'] == 'French', f"Expected 'French', got {deleted_locale['name']}"
        print("Test delete_locale: Passed")
    except LocaleManagementError as e:
        print(f"Test delete_locale: Failed with LocaleManagementError: {str(e)}")
    except Exception as e:
        print(f"Test delete_locale: Failed with Exception: {str(e)}")

    # 8. Test `delete_locales` function
    try:
        deleted_locales = setting_manager.delete_locales()
        assert isinstance(deleted_locales, list), f"Expected list, got {type(deleted_locales)}"
        print("Test delete_locales: Passed")
    except LocaleManagementError as e:
        print(f"Test delete_locales: Failed with LocaleManagementError: {str(e)}")
    except Exception as e:
        print(f"Test delete_locales: Failed with Exception: {str(e)}")

    # 9. Test `get_file_types` function
    try:
        file_types = setting_manager.get_file_types()
        assert isinstance(file_types, list), f"Expected list, got {type(file_types)}"
        print("Test get_file_types: Passed")
    except FileTypeError as e:
        print(f"Test get_file_types: Failed with FileTypeError: {str(e)}")
    except Exception as e:
        print(f"Test get_file_types: Failed with Exception: {str(e)}")

    # 10. Test `get_file_type` function
    try:
        file_type_id = 1  # Assume 1 is a valid ID
        file_type = setting_manager.get_file_type(file_type_id)
        assert isinstance(file_type, sqlite3.Row), f"Expected sqlite3.Row, got {type(file_type)}"
        assert file_type['id'] == file_type_id, f"Expected ID {file_type_id}, got {file_type['id']}"
        print("Test get_file_type: Passed")
    except FileTypeError as e:
        print(f"Test get_file_type: Failed with FileTypeError: {str(e)}")
    except Exception as e:
        print(f"Test get_file_type: Failed with Exception: {str(e)}")

    # 11. Test `add_file_type` function
    try:
        new_file_type = setting_manager.add_file_type('Web App', 'CSS', '.css')
        assert new_file_type['name'] == 'CSS', f"Expected 'CSS', got {new_file_type['name']}"
        assert new_file_type['extension'] == '.css', f"Expected '.css', got {new_file_type['extension']}"
        print("Test add_file_type: Passed")
    except FileTypeError as e:
        print(f"Test add_file_type: Failed with FileTypeError: {str(e)}")
    except Exception as e:
        print(f"Test add_file_type: Failed with Exception: {str(e)}")

    # 12. Test `update_file_type` function
    try:
        file_type_id = new_file_type['id']
        updated_file_type = setting_manager.update_file_type(file_type_id, {'name': 'JavaScript', 'extension': '.js'})
        assert updated_file_type['name'] == 'JavaScript', f"Expected 'JavaScript', got {updated_file_type['name']}"
        assert updated_file_type['extension'] == '.js', f"Expected '.js', got {updated_file_type['extension']}"
        print("Test update_file_type: Passed")
    except FileTypeError as e:
        print(f"Test update_file_type: Failed with FileTypeError: {str(e)}")
    except Exception as e:
        print(f"Test update_file_type: Failed with Exception: {str(e)}")

    # 13. Test `delete_file_type` function
    try:
        deleted_file_type = setting_manager.delete_file_type(file_type_id)
        assert deleted_file_type['id'] == file_type_id, f"Expected ID {file_type_id}, got {deleted_file_type['id']}"
        assert deleted_file_type['name'] == 'JavaScript', f"Expected 'JavaScript', got {deleted_file_type['name']}"
        print("Test delete_file_type: Passed")
    except FileTypeError as e:
        print(f"Test delete_file_type: Failed with FileTypeError: {str(e)}")
    except Exception as e:
        print(f"Test delete_file_type: Failed with Exception: {str(e)}")

    # 14. Test `delete_file_types` function
    try:
        deleted_file_types = setting_manager.delete_file_types()
        assert isinstance(deleted_file_types, list), f"Expected list, got {type(deleted_file_types)}"
        print("Test delete_file_types: Passed")
    except FileTypeError as e:
        print(f"Test delete_file_types: Failed with FileTypeError: {str(e)}")
    except Exception as e:
        print(f"Test delete_file_types: Failed with Exception: {str(e)}")



9. project_manager.py:

from db_manager import DBManager  # Import DBManager from the same module
from datetime import datetime
from error_manager import (
    DatabaseError,
    InitializationError,
    InvalidUserInputError
)

class ProjectManager:
    """
    The ProjectManager class handles all project-related functionalities for the AutoLoc app.
    It manages CRUD operations for projects using the DBManager.
    """

    def __init__(self):
        try:
            self.db_manager = DBManager()  # Initialize DBManager for database operations
        except InitializationError as e:
            raise InitializationError(f"ProjectManager Initialization Error: {str(e)}")

    def get_projects(self):
        """
        Retrieves all projects from the projects table.
        :return: A list of projects or an error message
        """
        try:
            records = self.db_manager.get_records('projects')
            return records
        except DatabaseError as e:
            raise DatabaseError(f"ProjectManager Get Projects Error: {str(e)}")

    def get_project(self, project_id):
        """
        Retrieves a specific project from the projects table.
        :param project_id: The ID of the project to retrieve
        :return: The project record or an error message
        """
        try:
            record = self.db_manager.get_record('projects', project_id)
            return record
        except DatabaseError as e:
            raise DatabaseError(f"ProjectManager Get Project Error: {str(e)}")

    def add_project(self, name, client, description, status="In Progress", start_date=None, end_date=None, lead_engineer=None):
        """
        Adds a new project record to the projects table.
        :param name: Name of the project
        :param client: Client associated with the project
        :param description: Description of the project
        :param status: Status of the project (default: "In Progress")
        :param start_date: Start date of the project (optional)
        :param end_date: End date of the project (optional)
        :param lead_engineer: Lead engineer of the project (optional)
        :return: The inserted project record or an error message
        """
        try:
            unique_id = self._generate_unique_id(name, client)
            current_date = datetime.now().strftime('%Y-%m-%d')
            data = {
                'name': name,
                'unique_id': unique_id,
                'client': client,
                'description': description,
                'status': status,
                'start_date': start_date,
                'end_date': end_date,
                'last_updated_date': current_date,  # Set to the current date
                'lead_engineer': lead_engineer
            }
            result = self.db_manager.insert_record('projects', data)
            return result
        except DatabaseError as e:
            raise DatabaseError(f"ProjectManager Add Project Error: {str(e)}")

    def update_project(self, project_id, name, client, description, status="In Progress", start_date=None, end_date=None, lead_engineer=None):
        """
        Updates a project record in the projects table.
        :param project_id: The ID of the project to update
        :param name: New name of the project
        :param client: New client associated with the project
        :param description: New description of the project
        :param status: New status of the project
        :param start_date: New start date of the project (optional)
        :param end_date: New end date of the project (optional)
        :param lead_engineer: New lead engineer of the project (optional)
        :return: The updated project record or an error message
        """
        try:
            unique_id = self._generate_unique_id(name, client)
            current_date = datetime.now().strftime('%Y-%m-%d')
            data = {
                'name': name,
                'unique_id': unique_id,
                'client': client,
                'description': description,
                'status': status,
                'start_date': start_date,
                'end_date': end_date,
                'last_updated_date': current_date,  # Set to the current date
                'lead_engineer': lead_engineer
            }
            result = self.db_manager.update_record('projects', project_id, data)
            return result
        except DatabaseError as e:
            raise DatabaseError(f"ProjectManager Update Project Error: {str(e)}")

    def delete_project(self, project_id):
        """
        Deletes a specific project record from the projects table.
        :param project_id: The ID of the project to delete
        :return: The deleted project record or an error message
        """
        try:
            result = self.db_manager.delete_record('projects', project_id)
            return result
        except DatabaseError as e:
            raise DatabaseError(f"ProjectManager Delete Project Error: {str(e)}")

    def delete_projects(self):
        """
        Deletes all project records from the projects table.
        :return: A list of deleted project records or an error message
        """
        try:
            result = self.db_manager.delete_records('projects')
            return result
        except DatabaseError as e:
            raise DatabaseError(f"ProjectManager Delete Projects Error: {str(e)}")

    def _abbreviate(self, text):
        """
        Creates an abbreviation from the given text by taking the first letter of each word.
        :param text: The text to abbreviate
        :return: The abbreviation as a string
        """
        try:
            words = text.split()  # Split the text into words
            abbreviation = ''.join(word[0].upper() for word in words)  # Take the first letter of each word and convert to uppercase
            return abbreviation
        except Exception as e:
            raise Exception(f"ProjectManager Abbreviate Error: {str(e)}")

    def _generate_unique_id(self, name, client):
        """
        Generates a unique identifier for a project based on the abbreviated name and client.
        :param name: The project name
        :param client: The client associated with the project
        :return: A unique identifier string
        """
        try:
            name_abbr = self._abbreviate(name)  # Abbreviate the project name
            client_abbr = self._abbreviate(client)  # Abbreviate the client name
            unique_id = f"{name_abbr}_{client_abbr}_{datetime.now().strftime('%Y%m%d%H%M%S')}"
            return unique_id
        except Exception as e:
            raise Exception(f"ProjectManager Generate Unique ID Error: {str(e)}")



10. test_project_manager.py:

    from project_manager import ProjectManager
    from error_manager import (
        DatabaseError,
        InitializationError,
        InvalidUserInputError
    )

    # Create an instance of ProjectManager
    project_manager = ProjectManager()

    # 1. Test `get_projects` function
    try:
        projects = project_manager.get_projects()
        assert isinstance(projects, list), f"Expected list, got {type(projects)}"
        print("Test get_projects: Passed")
    except DatabaseError as e:
        print(f"Test get_projects: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test get_projects: Failed with Exception: {str(e)}")

    # 2. Test `get_project` function
    try:
        project_id = 1  # Assume 1 is a valid ID
        project = project_manager.get_project(project_id)
        assert isinstance(project, sqlite3.Row), f"Expected sqlite3.Row, got {type(project)}"
        assert project['id'] == project_id, f"Expected ID {project_id}, got {project['id']}"
        print("Test get_project: Passed")
    except DatabaseError as e:
        print(f"Test get_project: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test get_project: Failed with Exception: {str(e)}")

    # 3. Test `add_project` function
    try:
        new_project = project_manager.add_project(
            name="New Project",
            client="Client A",
            description="A test project",
            status="In Progress",
            start_date="2024-09-13",
            end_date=None,
            lead_engineer="Engineer A"
        )
        assert new_project['name'] == 'New Project', f"Expected 'New Project', got {new_project['name']}"
        assert new_project['client'] == 'Client A', f"Expected 'Client A', got {new_project['client']}"
        print("Test add_project: Passed")
    except DatabaseError as e:
        print(f"Test add_project: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test add_project: Failed with Exception: {str(e)}")

    # 4. Test `update_project` function
    try:
        project_id = new_project['id']
        updated_project = project_manager.update_project(
            project_id,
            name="Updated Project",
            client="Client B",
            description="Updated description",
            status="Completed",
            start_date="2024-09-13",
            end_date="2024-12-31",
            lead_engineer="Engineer B"
        )
        assert updated_project['name'] == 'Updated Project', f"Expected 'Updated Project', got {updated_project['name']}"
        assert updated_project['client'] == 'Client B', f"Expected 'Client B', got {updated_project['client']}"
        print("Test update_project: Passed")
    except DatabaseError as e:
        print(f"Test update_project: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test update_project: Failed with Exception: {str(e)}")

    # 5. Test `delete_project` function
    try:
        deleted_project = project_manager.delete_project(project_id)
        assert deleted_project['id'] == project_id, f"Expected ID {project_id}, got {deleted_project['id']}"
        assert deleted_project['name'] == 'Updated Project', f"Expected 'Updated Project', got {deleted_project['name']}"
        print("Test delete_project: Passed")
    except DatabaseError as e:
        print(f"Test delete_project: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test delete_project: Failed with Exception: {str(e)}")

    # 6. Test `delete_projects` function
    try:
        deleted_projects = project_manager.delete_projects()
        assert isinstance(deleted_projects, list), f"Expected list, got {type(deleted_projects)}"
        print("Test delete_projects: Passed")
    except DatabaseError as e:
        print(f"Test delete_projects: Failed with DatabaseError: {str(e)}")
    except Exception as e:
        print(f"Test delete_projects: Failed with Exception: {str(e)}")

    # 7. Test `_abbreviate` function
    try:
        text = "Sample Project"
        abbreviation = project_manager._abbreviate(text)
        assert abbreviation == "SP", f"Expected 'SP', got {abbreviation}"
        print("Test _abbreviate: Passed")
    except Exception as e:
        print(f"Test _abbreviate: Failed with Exception: {str(e)}")

    # 8. Test `_generate_unique_id` function
    try:
        unique_id = project_manager._generate_unique_id("Sample Project", "Client X")
        assert isinstance(unique_id, str) and len(unique_id) > 0, f"Expected non-empty string, got {unique_id}"
        print("Test _generate_unique_id: Passed")
    except Exception as e:
        print(f"Test _generate_unique_id: Failed with Exception: {str(e)}")

