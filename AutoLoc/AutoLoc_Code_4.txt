Read this file as a continuation from 'AutoLoc_Code_3.txt' file's content.

15. l10n_manager.py: in `managers` module:

# l10n_manager.py

from PySide6.QtCore import QObject, Signal
from source_code_manager import SourceCodeManager
from setting_manager import SettingManager
from error_manager import (
    InitializationError,
    InvalidUserInputError,
    LocalizationRenderError
)

# Import all the localizer classes
from localizers.web_localizers.web_app_html_file_localizer import WebAppHTMLFileLocalizer
from localizers.web_localizers.web_app_js_file_localizer import WebAppJSFileLocalizer
from localizers.web_localizers.web_app_ejs_file_localizer import WebAppEJSFileLocalizer
from localizers.web_localizers.web_app_jsx_file_localizer import WebAppJSXFileLocalizer
from localizers.web_localizers.web_app_ts_file_localizer import WebAppTSFileLocalizer
from localizers.web_localizers.web_app_tsx_file_localizer import WebAppTSXFileLocalizer
from localizers.web_localizers.web_app_vue_file_localizer import WebAppVueFileLocalizer
from localizers.web_localizers.web_app_json_file_localizer import WebAppJSONFileLocalizer
from localizers.web_localizers.web_app_csv_file_localizer import WebAppCSVFileLocalizer

from localizers.android_localizers.android_app_xml_file_localizer import AndroidAppXMLFileLocalizer
from localizers.android_localizers.android_app_java_file_localizer import AndroidAppJavaFileLocalizer
from localizers.android_localizers.android_app_kotlin_file_localizer import AndroidAppKotlinFileLocalizer

from localizers.ios_localizers.ios_app_swift_file_localizer import IOSAppSwiftFileLocalizer
from localizers.ios_localizers.ios_app_objc_m_file_localizer import IOSAppObjcMFileLocalizer
from localizers.ios_localizers.ios_app_objc_h_file_localizer import IOSAppObjcHFileLocalizer
from localizers.ios_localizers.ios_app_strings_file_localizer import IOSAppStringsFileLocalizer
from localizers.ios_localizers.ios_app_storyboard_file_localizer import IOSAppStoryboardFileLocalizer
from localizers.ios_localizers.ios_app_xib_file_localizer import IOSAppXIBFileLocalizer
from localizers.ios_localizers.ios_app_plist_file_localizer import IOSAppPListFileLocalizer

from localizers.java_localizers.java_app_xhtml_file_localizer import JavaAppXHTMLFileLocalizer
from localizers.java_localizers.java_app_xml_file_localizer import JavaAppXMLFileLocalizer
from localizers.java_localizers.java_app_java_file_localizer import JavaAppJavaFileLocalizer
from localizers.java_localizers.java_app_properties_file_localizer import JavaAppPropertiesFileLocalizer


class L10nManager(QObject):
    """
    The L10nManager class handles all localization procedures of the AutoLoc app.
    It coordinates the localization of different source code files according to their types.
    """
    
    # Define signals to be emitted during localization
    localization_complete_signal = Signal(str, bool)

    def __init__(self, source_code_id):
        super().__init__()
        try:
            # Initialize the source code manager
            self.source_code_manager = SourceCodeManager(source_code_id)
            self.source_code = self.source_code_manager.get_source_code(source_code_id)
            self.source_code_type = self.source_code['code_type']
            self.source_code_status = self.source_code['status']

            # Initialize the setting manager and get active file types
            self.setting_manager = SettingManager()
            self.active_file_types = self.get_active_file_types()

            # Validate source code type
            self.accepted_source_code_types = ["Web App", "Android App", "iOS App", "Java App"]
            if self.source_code_type not in self.accepted_source_code_types:
                raise InvalidUserInputError(f"L10nManager Initialization Error: Unsupported source code type '{self.source_code_type}'")

            # Get files based on active file types
            self.files = self.get_files()
        except (InitializationError, InvalidUserInputError) as e:
            raise InitializationError(f"L10nManager Initialization Error: {str(e)}")


    def get_active_file_types(self):
        """
        Retrieves and returns active file types for the current source code type.
        """
        try:
            file_types = self.setting_manager.get_file_types()
            return [ft['extension'] for ft in file_types if ft['is_active'] and ft['code_type'] == self.source_code_type]
        except Exception as e:
            raise InvalidUserInputError(f"L10nManager Error in get_active_file_types: {str(e)}")

    def get_files(self):
        """
        Retrieves files categorized by their extensions based on active file types.
        """
        files_dict = {}
        try:
            for extension in self.active_file_types:
                files_by_extension = self.get_files_by_extension(extension)
                if files_by_extension:
                    files_dict[extension] = files_by_extension
            return files_dict
        except Exception as e:
            raise InvalidUserInputError(f"L10nManager Error in get_files: {str(e)}")

    def get_files_by_extension(self, extension):
        """
        Retrieves files with the specified extension from the source code's localized path.
        """
        try:
            localized_path = self.source_code_manager.get_localized_source_code_path(self.source_code['id'])
            files = []
            for root, _, filenames in os.walk(localized_path):
                for filename in filenames:
                    if filename.endswith(extension):
                        files.append(os.path.relpath(os.path.join(root, filename), localized_path))
            return files
        except Exception as e:
            raise InvalidUserInputError(f"L10nManager Error in get_files_by_extension: {str(e)}")

    def localize_source_code(self):
        """
        Initiates the localization process based on the source code type.
        """
        try:
            # Check if the source code has already been localized
            if self.source_code_status == "Localized":
                raise LocalizationRenderError("L10nManager Error: The source code has already been localized!")

            if self.source_code_type == "Web App":
                self.localize_web_files()
            elif self.source_code_type == "Android App":
                self.localize_android_files()
            elif self.source_code_type == "iOS App":
                self.localize_ios_files()
            elif self.source_code_type == "Java App":
                self.localize_java_files()
            else:
                raise InvalidUserInputError(f"L10nManager Error in localize_source_code: Unsupported source code type '{self.source_code_type}'")
        except LocalizationRenderError as e:
            self.localization_complete_signal.emit(f"L10nManager Error in localize_source_code: {str(e)}", False)
            return  # Stop the localization process
        except Exception as e:
            raise LocalizationRenderError(f"L10nManager Error in localize_source_code: {str(e)}")


    def localize_web_files(self):
        """
        Localizes web app files using the respective localizer classes.
        """
        try:
            if not self.files:
                raise LocalizationRenderError("L10nManager Error in localize_web_files: No files found for localization.")

            # Map file extensions to their respective localizer classes
            localizer_classes = {
                '.html': WebAppHTMLFileLocalizer,
                '.js': WebAppJSFileLocalizer,
                '.ejs': WebAppEJSFileLocalizer,
                '.jsx': WebAppJSXFileLocalizer,
                '.ts': WebAppTSFileLocalizer,
                '.tsx': WebAppTSXFileLocalizer,
                '.vue': WebAppVueFileLocalizer,
                '.json': WebAppJSONFileLocalizer,
                '.csv': WebAppCSVFileLocalizer,
            }

            for extension, files in self.files.items():
                if files and extension in localizer_classes:
                    localizer = localizer_classes[extension](self.source_code['id'], files)  # Pass source_code_id and files list
                    localizer.localization_complete_signal.connect(self.localization_complete_signal.emit)
                    localizer.start()  # Start the localizer thread

            self.source_code_manager.update_source_code(self.source_code['id'], {'status': 'Localized'})
        except Exception as e:
            raise LocalizationRenderError(f"L10nManager Error in localize_web_files: {str(e)}")

    def localize_android_files(self):
        """
        Localizes Android app files using the respective localizer classes.
        """
        try:
            if not self.files:
                raise LocalizationRenderError("L10nManager Error in localize_android_files: No files found for localization.")

            localizer_classes = {
                '.xml': AndroidAppXMLFileLocalizer,
                '.java': AndroidAppJavaFileLocalizer,
                '.kt': AndroidAppKotlinFileLocalizer,
            }

            for extension, files in self.files.items():
                if files and extension in localizer_classes:
                    localizer = localizer_classes[extension](self.source_code['id'], files)  # Pass source_code_id and files list
                    localizer.localization_complete_signal.connect(self.localization_complete_signal.emit)
                    localizer.start()  # Start the localizer thread

            self.source_code_manager.update_source_code(self.source_code['id'], {'status': 'Localized'})
        except Exception as e:
            raise LocalizationRenderError(f"L10nManager Error in localize_android_files: {str(e)}")

    def localize_ios_files(self):
        """
        Localizes iOS app files using the respective localizer classes.
        """
        try:
            if not self.files:
                raise LocalizationRenderError("L10nManager Error in localize_ios_files: No files found for localization.")

            localizer_classes = {
                '.swift': IOSAppSwiftFileLocalizer,
                '.m': IOSAppObjcMFileLocalizer,
                '.h': IOSAppObjcHFileLocalizer,
                '.strings': IOSAppStringsFileLocalizer,
                '.storyboard': IOSAppStoryboardFileLocalizer,
                '.xib': IOSAppXIBFileLocalizer,
                '.plist': IOSAppPListFileLocalizer,
            }

            for extension, files in self.files.items():
                if files and extension in localizer_classes:
                    localizer = localizer_classes[extension](self.source_code['id'], files)  # Pass source_code_id and files list
                    localizer.localization_complete_signal.connect(self.localization_complete_signal.emit)
                    localizer.start()  # Start the localizer thread

            self.source_code_manager.update_source_code(self.source_code['id'], {'status': 'Localized'})
        except Exception as e:
            raise LocalizationRenderError(f"L10nManager Error in localize_ios_files: {str(e)}")

    def localize_java_files(self):
        """
        Localizes Java app files using the respective localizer classes.
        """
        try:
            if not self.files:
                raise LocalizationRenderError("L10nManager Error in localize_java_files: No files found for localization.")

            localizer_classes = {
                '.xhtml': JavaAppXHTMLFileLocalizer,
                '.xml': JavaAppXMLFileLocalizer,
                '.java': JavaAppJavaFileLocalizer,
                '.properties': JavaAppPropertiesFileLocalizer,
            }

            for extension, files in self.files.items():
                if files and extension in localizer_classes:
                    localizer = localizer_classes[extension](self.source_code['id'], files)  # Pass source_code_id and files list
                    localizer.localization_complete_signal.connect(self.localization_complete_signal.emit)
                    localizer.start()  # Start the localizer thread

            self.source_code_manager.update_source_code(self.source_code['id'], {'status': 'Localized'})
        except Exception as e:
            raise LocalizationRenderError(f"L10nManager Error in localize_java_files: {str(e)}")





16. localizers.web_localizers.web_app_file_localizer.py:

# web_app_file_localizer.py

import os
import json
from pathlib import Path
from PySide6.QtCore import QObject, Signal
from setting_manager import SettingManager
from source_code_manager import SourceCodeManager
from error_manager import (
    InitializationError,
    InvalidUserInputError,
    ResourceFileError,
)

class WebAppFileLocalizer(QObject):
    """
    The WebAppFileLocalizer class serves as the base class for all web app file type localizer classes.
    It manages common functionalities such as progress tracking, key generation, and saving extracted strings to resource files.
    """

    def __init__(self, source_code_id):
        super().__init__()
        try:
            # Initialize necessary managers
            self.setting_manager = SettingManager()
            self.source_code_manager = SourceCodeManager(source_code_id)
            
            # Get source code information
            self.source_code = self.source_code_manager.get_source_code(source_code_id)
            self.source_locale = self.source_code['source_locale']
            self.app_settings = self.setting_manager.get_app_settings()

            # Initialize paths
            self.locales_path = Path(self.source_code['localized_source_code_path']) / "locales"

            # Ensure the locales directory exists
            self.locales_path.mkdir(parents=True, exist_ok=True)
            
            # Get target locales for the source code
            self.target_locales = self.setting_manager.get_target_locales(source_code_id)
        except (InitializationError, InvalidUserInputError) as e:
            raise InitializationError(f"WebAppFileLocalizer Initialization Error: {str(e)}")

    def generate_key(self, file_path):
        """
        Generates a unique string identifier key for the extracted strings.

        :param file_path: The path of the file being processed
        :return: A unique key string
        """
        try:
            # Remove the file extension from the file path
            namespace_prefix = f"{Path(file_path).stem}:" if self.app_settings.get('use_key_namespace', False) else ""
            existing_keys = self._get_existing_keys(file_path)
            new_key_index = len(existing_keys) + 1
            return f"{namespace_prefix}str_{new_key_index}"
        except Exception as e:
            raise InvalidUserInputError(f"WebAppFileLocalizer Error in generate_key: {str(e)}")

    def save_resource_files(self, data, file_path):
        """
        Saves the extracted strings in JSON format for both source and target locales.

        :param data: The JSON data to save
        :param file_path: The path to the file being processed
        """
        try:
            # Remove extension from file path and create corresponding JSON file path
            json_file_name = Path(file_path).with_suffix('.json').as_posix()

            # Save data for source locale
            source_locale_path = self.locales_path / self.source_locale / json_file_name
            self._write_json_file(data, source_locale_path)

            # Save data for each target locale
            for locale in self.target_locales:
                locale_path = self.locales_path / locale['code'] / json_file_name
                self._write_json_file(data, locale_path)
        except Exception as e:
            raise ResourceFileError(f"WebAppFileLocalizer Error in save_resource_files: {str(e)}")

    def _get_existing_keys(self, file_path):
        """
        Retrieves existing keys from the JSON resource file for the given file path.

        :param file_path: The path of the file being processed
        :return: A set of existing keys in the resource file
        """
        try:
            json_file_name = Path(file_path).with_suffix('.json').as_posix()
            source_locale_path = self.locales_path / self.source_locale / json_file_name

            if source_locale_path.exists():
                with open(source_locale_path, 'r', encoding='utf-8') as json_file:
                    data = json.load(json_file)
                    return set(data.keys())
            return set()
        except Exception as e:
            raise ResourceFileError(f"WebAppFileLocalizer Error in _get_existing_keys: {str(e)}")

    def _write_json_file(self, data, file_path):
        """
        Writes JSON data to the specified file path, ensuring the directory exists.

        :param data: The JSON data to write
        :param file_path: The path to the JSON file
        """
        try:
            file_path.parent.mkdir(parents=True, exist_ok=True)
            with open(file_path, 'w', encoding='utf-8') as json_file:
                json.dump(data, json_file, ensure_ascii=False, indent=4)
        except Exception as e:
            raise ResourceFileError(f"WebAppFileLocalizer Error in _write_json_file: {str(e)}")




17. web_app_html_file_localizer.py:

# web_app_html_file_localizer.py

import os
from pathlib import Path
from PySide6.QtCore import QThread, Signal
from bs4 import BeautifulSoup
from web_app_file_localizer import WebAppFileLocalizer
from error_manager import LocalizationRenderError, ResourceFileError, InvalidUserInputError


class WebAppHTMLFileLocalizer(QThread, WebAppFileLocalizer):
    """
    The WebAppHTMLFileLocalizer handles all HTML file-specific localization procedures.
    It inherits the WebAppFileLocalizer class and runs on its own PySide6 Thread.
    """

    localization_complete_signal = Signal(str, bool)

    def __init__(self, source_code_id, files):
        super().__init__(source_code_id)
        self.files = files

        # Tags for localization
        self.target_tags = ['title', 'div', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'address', 'pre', 'blockquote',
                            'li', 'figcaption', 'caption', 'td', 'th', 'label', 'option']
        self.special_tags = ['meta', 'img']
        self.nav_tags = ['a', 'button']
        self.formatting_tags = ['span', 'br', 'b', 'strong', 'i', 'em', 'mark', 'small', 'del', 'ins', 'sub', 'sup',
                                'u', 's', 'abbr', 'code', 'kbd', 'samp', 'var', 'cite', 'q', 'dfn', 'time', 'bdi',
                                'bdo', 'ruby', 'rt', 'rp', 'wbr']

    def run(self):
        """
        Executes the localization process in a separate thread.
        """
        try:
            self.localize_files()
        except Exception as e:
            self.localization_complete_signal.emit(f"WebAppHTMLFileLocalizer Error: {str(e)}", False)

    def localize_files(self):
        """
        Localizes all the files in self.files.
        """
        try:
            for html_file in self.files:
                self._process_html_file(html_file)
            self.localization_complete_signal.emit("Localization completed successfully.", True)
        except Exception as e:
            raise LocalizationRenderError(f"WebAppHTMLFileLocalizer Error in localize_files: {str(e)}")

    def _process_html_file(self, html_file):
        """
        Processes a given HTML file for localization.
        """
        try:
            with open(html_file, 'r', encoding='utf-8') as file:
                soup = BeautifulSoup(file, 'html.parser')

            self._mark_translatable_strings(soup, html_file)
            self._extract_and_save_strings(soup, html_file)

            if self.app_settings.get('duplicate_html', False):
                self._duplicate_html_file(soup, html_file)
        except Exception as e:
            raise LocalizationRenderError(f"WebAppHTMLFileLocalizer Error in _process_html_file: {str(e)}")

    def _mark_translatable_strings(self, soup, file_path):
        """
        Marks all translatable strings in the HTML content.
        """
        try:
            # Process target tags
            for tag in soup.find_all(self.target_tags):
                if 'data-i18n' in tag.attrs:
                    continue  # Skip tags that are already marked
                if self._is_inside_nav_or_formatting_tags(tag):
                    continue  # Skip if tag is inside a nav tag or formatting tag parent
                if tag.find(self.target_tags) or tag.find(self.special_tags):
                    continue  # Skip if tag contains another target tag or special tag as an immediate child

                if (tag.string and tag.string.strip()) or tag.get_text(strip=True):
                    tag['data-i18n'] = self.generate_key(file_path)
                elif self._has_nav_or_formatting_tags(tag):
                    tag['data-i18n'] = self.generate_key(file_path)

            # Process special tags
            for tag in soup.find_all(self.special_tags):
                if 'data-i18n' in tag.attrs:
                    continue  # Skip tags that are already marked
                if self._is_inside_nav_or_formatting_tags(tag):
                    continue  # Skip if tag is inside a nav tag
                if tag.name == 'img' and tag.has_attr('alt') and tag['alt'].strip():
                    tag['data-i18n'] = self.generate_key(file_path)
                elif tag.name == 'meta' and (tag.get('name') in ['description', 'author'] or tag.get('property') in ['og:title', 'og:description', 'og:site_name']):
                    if tag.has_attr('content') and tag['content'].strip():
                        tag['data-i18n'] = self.generate_key(file_path)

            # Process nav tags
            for tag in soup.find_all(self.nav_tags):
                if 'data-i18n' in tag.attrs:
                    continue  # Skip tags that are already marked
                if self._has_target_formatting_or_special_tags(tag):
                    tag['data-i18n'] = self.generate_key(file_path)
                elif any(sibling.name in self.target_tags for sibling in tag.find_next_siblings()):
                    tag['data-i18n'] = self.generate_key(file_path)

        except Exception as e:
            raise InvalidUserInputError(f"WebAppHTMLFileLocalizer Error in _mark_translatable_strings: {str(e)}")

    def _extract_and_save_strings(self, soup, html_file):
        """
        Extracts and saves the translatable strings to JSON files.
        """
        try:
            source_json = {}

            for tag in soup.find_all(attrs={"data-i18n": True}):
                key = tag['data-i18n'].split(':', 1)[1]  # Take the second part without namespace_suffix
                inner_html = ''.join(str(child) for child in tag.children).strip() if tag.children else None
                if inner_html and inner_html.strip():
                    source_json[key] = inner_html

            if source_json:
                self.save_resource_files(source_json, html_file)
        except Exception as e:
            raise ResourceFileError(f"WebAppHTMLFileLocalizer Error in _extract_and_save_strings: {str(e)}")

    def _duplicate_html_file(self, soup, html_file):
        """
        Duplicates the HTML file for each target locale and modifies the lang attribute.
        """
        try:
            source_locale = self.source_locale
            soup.html['lang'] = source_locale
            self._save_html_file(soup, html_file, source_locale, is_original=True)

            for target_locale in self.target_locales:
                duplicate_html = BeautifulSoup(str(soup), 'html.parser')
                duplicate_html.html['lang'] = target_locale['code']
                self._save_html_file(duplicate_html, html_file, target_locale['code'])
        except Exception as e:
            raise LocalizationRenderError(f"WebAppHTMLFileLocalizer Error in _duplicate_html_file: {str(e)}")

    def _save_html_file(self, soup, html_file, locale, is_original=False):
        """
        Saves the modified HTML file with the lang attribute.
        """
        try:
            file_dir, file_name = os.path.split(html_file)
            if is_original:
                new_file_path = os.path.join(file_dir, file_name)
            else:
                locale_dir = os.path.join(file_dir, "locales", locale)
                file_name_without_ext, file_ext = os.path.splitext(file_name)
                new_file_name = f"{file_name_without_ext}_{locale.replace('-', '_')}{file_ext}"
                new_file_path = os.path.join(locale_dir, new_file_name)

            os.makedirs(os.path.dirname(new_file_path), exist_ok=True)

            with open(new_file_path, 'w', encoding='utf-8') as file:
                file.write(soup.prettify())
        except Exception as e:
            raise ResourceFileError(f"WebAppHTMLFileLocalizer Error in _save_html_file: {str(e)}")

    def _has_nav_or_formatting_tags(self, tag):
        """
        Checks if a tag has nav_tags or formatting_tags children.
        """
        for child in tag.find_all(recursive=False):
            if child.name in self.nav_tags or child.name in self.formatting_tags:
                return True
        return False

    def _has_target_formatting_or_special_tags(self, tag):
        """
        Checks if a tag has target_tags, formatting_tags, or special_tags children.
        """
        for child in tag.find_all(recursive=False):
            if child.name in self.target_tags or child.name in self.formatting_tags or child.name in self.special_tags:
                return True
        return False

    def _is_inside_nav_or_formatting_tags(self, tag):
        """
        Checks if a tag is inside nav_tags or formatting_tags parents.
        """
        parent = tag.parent
        while parent is not None:
            if parent.name in self.nav_tags or parent.name in self.formatting_tags:
                return True
            parent = parent.parent
        return False



18. web_app_js_file_localizer.py:

# web_app_js_file_localizer.py

import re
from PySide6.QtCore import QThread, Signal
from web_app_file_localizer import WebAppFileLocalizer
from error_manager import LocalizationRenderError, ResourceFileError, InvalidUserInputError

class WebAppJSFileLocalizer(QThread, WebAppFileLocalizer):
    """
    The WebAppJSFileLocalizer handles all JS file-specific localization procedures.
    It inherits the WebAppFileLocalizer class and runs on its own PySide6 Thread.
    """

    localization_complete_signal = Signal(str, bool)

    def __init__(self, source_code_id, files):
        super().__init__(source_code_id)
        self.files = files

        # Regular expression patterns for identifying translatable strings in JS files
        self.translatable_patterns = [
            re.compile(r'"([^"\\]*(?:\\.[^"\\]*)*)"', re.MULTILINE),  # Matches simple strings in double quotes
            re.compile(r"`([^`\\]*(?:\\.[^`\\]*)*)`", re.MULTILINE),  # Matches template literals
            re.compile(r">\s*(.*?)\s*<", re.MULTILINE),               # Matches HTML content between tags
        ]

    def run(self):
        """
        Executes the localization process in a separate thread.
        """
        try:
            self.localize_files()
        except Exception as e:
            self.localization_complete_signal.emit(f"WebAppJSFileLocalizer Error: {str(e)}", False)

    def localize_files(self):
        """
        Localizes all the JS files in self.files.
        """
        try:
            for js_file in self.files:
                self._process_js_file(js_file)
            self.localization_complete_signal.emit("Localization completed successfully.", True)
        except Exception as e:
            raise LocalizationRenderError(f"WebAppJSFileLocalizer Error in localize_files: {str(e)}")

    def _process_js_file(self, js_file):
        """
        Processes an individual JS file for localization.

        :param js_file: The path to the JS file to process.
        """
        try:
            with open(js_file, 'r', encoding='utf-8') as file:
                content = file.read()

            self._mark_and_extract_strings(content, js_file)
        except Exception as e:
            raise LocalizationRenderError(f"WebAppJSFileLocalizer Error in _process_js_file: {str(e)}")

    def _mark_and_extract_strings(self, content, js_file):
        """
        Marks and extracts all the translatable strings in the JS file content and saves them to a JSON file.

        :param content: The content of the JS file.
        :param js_file: The path to the JS file being processed.
        """
        try:
            source_json = {}
            modified_content = content

            for pattern in self.translatable_patterns:
                matches = pattern.finditer(content)
                for match in matches:
                    original_string = match.group(0)
                    translatable_string = match.group(1).strip()  # Remove quotes or backticks around the string
                    if not translatable_string:
                        continue
                    
                    # Generate a unique key for the translatable string
                    key = self.generate_key(js_file)

                    # Adjust key if use_key_namespace is True
                    if self.app_settings.get('use_key_namespace', False):
                        key = key.split(':', 1)[1]  # Remove namespace_suffix from the key

                    # Save the extracted string to the JSON file
                    source_json[key] = translatable_string

                    # Replace the string in the content with "${translate('unique_id')}"
                    replacement_string = f"${{translate('{key}')}}"
                    modified_content = modified_content.replace(original_string, replacement_string)

            # Save the extracted strings to a JSON file
            if source_json:
                self.save_resource_files(source_json, js_file)

            # Save the modified JS file
            self._save_js_file(modified_content, js_file)
        except Exception as e:
            raise ResourceFileError(f"WebAppJSFileLocalizer Error in _mark_and_extract_strings: {str(e)}")

    def _save_js_file(self, content, js_file):
        """
        Saves the modified JS file to replace the original.

        :param content: The modified content of the JS file.
        :param js_file: The path to the JS file being saved.
        """
        try:
            with open(js_file, 'w', encoding='utf-8') as file:
                file.write(content)
        except Exception as e:
            raise ResourceFileError(f"WebAppJSFileLocalizer Error in _save_js_file: {str(e)}")








